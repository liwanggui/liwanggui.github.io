---
title: "LVS 负载均衡，介绍"
date: "2021-02-20T09:35:25+08:00"
draft: false
categories:
- devops
- lvs
tags:
- lvs
---

## LVS 介绍

Linux 虚拟服务器（Linux Virtual Server, LVS），是一个由章文嵩开发的一款自由软件。利用 LVS 可以实现高可用、可伸缩的 Web、Mail、Cache 等网络服务。 
LVS 具有很好的可伸缩性、可靠性和可管性，通过 LVS 要实现的最终目标是：利用 Linux 操作系统和 LVS 集群软件实现一个高可用、高性能、低成本的服务器应用集群。

常用的实现负载均衡集群的开源软件有: LVS、haproxy、Nginx 等

LVS 工作于 OSI模型的传输层, 也可以称为4层负载。Nginx 与 Haproxy 即可以工作在 4 层（传输层）也可以工作于 7 层 （应用层）。

LVM 集群架构由2部分组成：最前端是负载均衡层（Load Balancer），后端是服务器群组 (一般称其为 Real Server)

- 负载均衡层: 由于一台或多台负载调度器(Director Server)组成。 LVS 核心模板 IPVS 就安装在 Director Server 上，而 Director 的主要作用类似于一个路由器，它含有为完成 LVS 功能所设定的路由表，通过这些路由表把用户的请求分发给服务器群组的应用服务器（Real Server）。 同时，在 Director Server 上还要安装对 Real Server 的监控模块 Ldirectord, 此模块用于监测各个 Real Server 服务健康状况。 在 Real Server 不可用时可以将其从 LVS 路由表中删除，在恢复时加入。
- 服务器群组层：由一组实际提供服务的机器组成，Real Server 可以在同一个网络中，也可以在不同网络中或者不同物理位置。

Linux 内核原生内转了 LVS 的各个模块，不用任何设置就可以支持 LVS 功能。

## IPVS 负载均衡实现方式

IPVS 实现负载均衡的方式有3种，分别是 NAT, TUN 和 DR。 

### VS/NAT (Virtual Server via Network Address Translation)

VS/NAT 方式使用网络地址翻译技术实现虚拟服务器。当用户请求到达调度器时，调度器将请求报文的目标地址(即虚拟IP地址)改写成选定的 RealServer 地址，同时将报文的目标端口也改成选定的 RealServer 的相应端口，最后将报文发送到选定的RealServer。 在服务器得到数据后， RealServer 将数据返回给用户时，需要再次经过负载均衡调度器将报文的源地址和源端口改成虚拟IP地址和相应的端口，然后把数据发送给用户，完成整个负载调度过程。

可以看出，在 NAT 方式下，用户请求和响应的报文都需要经过负载均衡调度器重写，当请求越来越多时，调度器的处理能力将成为瓶颈。

### VS/TUN (Virtual Server via IP Tunneling)

VS/TUN 方式是通过 IP 隧道技术实现虚拟服务器。这种方式的连接调度和管理与 VS/NAT 方式一样，只是报文转发方法不同。 在 VS/TUN 方式中，调度器采用 IP 隧道技术将用户的请求转发到某个 RealServer，而这个 RealServer 将直接响应用户的请求，不再经过前端调度器。 此外，对 RealServer 的地域位置没有要求。 因为在 TUN 方式中，调度器将只处理用户请求的报文，从而使集群系统的吞吐量大大提高。

### VS/DR (Virtual Server via Direct Routing)

VS/DR 就是直接路由技术实现虚拟服务器，这种方式的连接调度和管理与前两种一样，但它的报文转发方法又有所不同，VS/DR 通过改写请求报文的 MAC 地址，将请求发送到 RealServer， 而 RealServer 将响应直接返回给用户，免去了 VS/TUN的 IP 隧道开销。 这种方式是3咱负载调度方式中性能最好的，但是要求 Director Server 与 RealServer 必须由一块网卡连在同一物理网段上。

## 负载调度算法

根据前面的介绍，我们了解了LVS的三种工作模式，但不管实际环境中采用的是哪种模式，调度算法进行调度的策略与算法都是LVS的核心技术，LVS在内核中主要实现了一下十种调度算法。

### 1.轮询调度

轮询调度（Round Robin 简称'RR'）算法就是按依次循环的方式将请求调度到不同的服务器上，该算法最大的特点就是实现简单。轮询算法假设所有的服务器处理请求的能力都一样的，调度器会将所有的请求平均分配给每个真实服务器。

### 2.加权轮询调度

加权轮询（Weight Round Robin 简称'WRR'）算法主要是对轮询算法的一种优化与补充，LVS会考虑每台服务器的性能，并给每台服务器添加一个权值，如果服务器A的权值为1，服务器B的权值为2，则调度器调度到服务器B的请求会是服务器A的两倍。权值越高的服务器，处理的请求越多。

### 3.最小连接调度

最小连接调度（Least Connections 简称'LC'）算法是把新的连接请求分配到当前连接数最小的服务器。最小连接调度是一种动态的调度算法，它通过服务器当前活跃的连接数来估计服务器的情况。调度器需要记录各个服务器已建立连接的数目，当一个请求被调度到某台服务器，其连接数加1；当连接中断或者超时，其连接数减1。

（集群系统的真实服务器具有相近的系统性能，采用最小连接调度算法可以比较好地均衡负载。)

### 4.加权最小连接调度

加权最少连接（Weight Least Connections 简称'WLC'）算法是最小连接调度的超集，各个服务器相应的权值表示其处理性能。服务器的缺省权值为1，系统管理员可以动态地设置服务器的权值。加权最小连接调度在调度新连接时尽可能使服务器的已建立连接数和其权值成比例。调度器可以自动问询真实服务器的负载情况，并动态地调整其权值。

### 5.基于局部的最少连接

基于局部的最少连接调度（Locality-Based Least Connections 简称'LBLC'）算法是针对请求报文的目标IP地址的 负载均衡调度，目前主要用于Cache集群系统，因为在Cache集群客户请求报文的目标IP地址是变化的。这里假设任何后端服务器都可以处理任一请求，算法的设计目标是在服务器的负载基本平衡情况下，将相同目标IP地址的请求调度到同一台服务器，来提高各台服务器的访问局部性和Cache命中率，从而提升整个集群系统的处理能力。LBLC调度算法先根据请求的目标IP地址找出该目标IP地址最近使用的服务器，若该服务器是可用的且没有超载，将请求发送到该服务器；若服务器不存在，或者该服务器超载且有服务器处于一半的工作负载，则使用'最少连接'的原则选出一个可用的服务器，将请求发送到服务器。

### 6.带复制的基于局部性的最少连接

带复制的基于局部性的最少连接（Locality-Based Least Connections with Replication  简称'LBLCR'）算法也是针对目标IP地址的负载均衡，目前主要用于Cache集群系统，它与LBLC算法不同之处是它要维护从一个目标IP地址到一组服务器的映射，而LBLC算法维护从一个目标IP地址到一台服务器的映射。按'最小连接'原则从该服务器组中选出一一台服务器，若服务器没有超载，将请求发送到该服务器；若服务器超载，则按'最小连接'原则从整个集群中选出一台服务器，将该服务器加入到这个服务器组中，将请求发送到该服务器。同时，当该服务器组有一段时间没有被修改，将最忙的服务器从服务器组中删除，以降低复制的程度。

### 7.目标地址散列调度

目标地址散列调度（Destination Hashing 简称'DH'）算法先根据请求的目标IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。

### 8.源地址散列调度

源地址散列调度（Source Hashing  简称'SH'）算法先根据请求的源IP地址，作为散列键（Hash Key）从静态分配的散列表找出对应的服务器，若该服务器是可用的且并未超载，将请求发送到该服务器，否则返回空。它采用的散列函数与目标地址散列调度算法的相同，它的算法流程与目标地址散列调度算法的基本相似。

### 9.最短的期望的延迟

最短的期望的延迟调度（Shortest Expected Delay 简称'SED'）算法基于WLC算法。举个例子吧，ABC三台服务器的权重分别为1、2、3 。那么如果使用WLC算法的话一个新请求进入时它可能会分给ABC中的任意一个。使用SED算法后会进行一个运算

- A：（1+1）/1=2
- B：（1+2）/2=3/2
- C：（1+3）/3=4/3

就把请求交给得出运算结果最小的服务器。

### 10.最少队列调度

最少队列调度（Never Queue 简称'NQ'）算法，无需队列。如果有realserver的连接数等于0就直接分配过去，不需要在进行SED运算。
