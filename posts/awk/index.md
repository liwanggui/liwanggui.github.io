# Linux 文本三剑客: awk


## awk 文本处理

`awk` 是一种很棒的语言，它适合文本处理和报表生成，其语法较为常见，借鉴了某些语言的一些精华，如 `C` 语言等。

在 `linux` 系统日常处理工作中，发挥很重要的作用，掌握了 `awk` 将会使你的工作变的高大上。

`awk` 是三剑客的老大，利剑出鞘，必会不同凡响。

### awk 内置变量

- `$0`  匹配当前记录整行数据
- `$1-$n` 匹配当前记录的第n个字段（列）
- `FS` 输入字段分隔符，默认是空格或制表符(tab)
- `RS` 输入记录分隔符，默认为换行符
- `NF` 当前记录的字段个数，就是有多个列
- `NR` 记录所有行数，就是行号，从1开始
- `OFS` 输出字段分隔符，默认也是空格
- `ORS` 输入的记录分隔符，默认为换行符

> 内置变量很多，更多参数自行查询

### awk 使用示例

#### 1. 统计 linux 系统下 tcp 协议所有网络状态条数

```bash
root@ops:~# ss -ant | awk '{++d[$1]} END {for (k in d){print k ": " d[k]}}' | grep -v State
LISTEN: 10
ESTAB: 1
```

*语法解析*

```bash
{
    # 定义一个数组 d, 键为 $1 (状态名), ++ 表示数组中键名相同时值自动加 1
    ++d[$1]
} END { # awk 在处理了输入文件中的所有行之后执行这个块
    # 输入数组中所有数据，k 是键名，通过键名取数据
    for (k in d){
        print k ": " d[k]
    }
}
```

#### 2. 求和并排序

文本有两列字段，用户名，充值金额。 在数据中用户可能会重复出现，现在需要统计出所有用户的金额总值并按降序排列

```bash
root@ops:~# cat b.txt
1234   100
1344   13
1242   783
1234   234
4563   21
4562   145
root@ops:~# awk '{d[$1]+=$2} END { for (n in d){print n ": " d[n]}}' b.txt | sort -nr -k 2
1242: 783
1234: 334
4562: 145
4563: 21
1344: 13
```

*awk 语法解析*

```bash
{ 
    # 定义一个数据，key 为用户名，value 为 充值金额，
    # 由于用户名会重复出现金额需要累加，所以使用 += 表达式进行赋值
    d[$1]+=$2
} END { 
    # 输入数据中所有值
    for (n in d){
        print n ": " d[n]
    }
}
```

#### 3. 列出占用 80 端口进程的 pid 并结束它

```bash
root@ops:~# lsof -i:80 | awk '{ if ($2 ~ /[0-9]/) {print $2}}' | xargs kill
30213
30232
30233
```

> 也可以使用: `ss -antp | grep ':80 ' | egrep -o 'pid=[0-9]{,5}' | tr -d 'pid=' | xargs kill `

